#!/usr/bin/env python3
"""
Malware Sample Packager
Safely packages suspected malware samples for analysis with password protection.
Standard password: "infected" (industry standard for malware samples)
"""

import os
import sys
import subprocess
import shutil
import zipfile
import platform
import tempfile
import urllib.request
from pathlib import Path

class MalwarePackager:
    def __init__(self):
        self.password = "infected"
        self.system = platform.system()
        self.temp_7z_dir = None
        self.downloaded_7z = False
        
    def download_7z_portable(self):
        """Download portable 7z if not available"""
        print("7z not found. Downloading portable version...")
        
        try:
            self.temp_7z_dir = tempfile.mkdtemp(prefix="7z_temp_")
            
            if self.system == "Windows":
                # Download 7z portable for Windows
                url = "https://www.7-zip.org/a/7zr.exe"
                seven_z_path = os.path.join(self.temp_7z_dir, "7z.exe")
                
                print(f"Downloading from {url}...")
                urllib.request.urlretrieve(url, seven_z_path)
                
                # Add to PATH temporarily
                os.environ['PATH'] = self.temp_7z_dir + os.pathsep + os.environ['PATH']
                self.downloaded_7z = True
                print(f"✓ Downloaded 7z to temporary location")
                return True
                
            elif self.system == "Linux":
                # Try to use package manager
                print("Attempting to install 7z via package manager...")
                try:
                    subprocess.run(['which', 'apt-get'], check=True, capture_output=True)
                    print("Note: This requires sudo. Install manually with: sudo apt-get install p7zip-full")
                    return False
                except:
                    print("Note: Install 7z manually with your package manager (p7zip-full)")
                    return False
                    
            elif self.system == "Darwin":  # macOS
                print("Note: Install 7z with: brew install p7zip")
                return False
            
            return False
            
        except Exception as e:
            print(f"✗ Failed to download 7z: {e}")
            return False
    
    def cleanup_7z(self):
        """Clean up downloaded 7z"""
        if self.downloaded_7z and self.temp_7z_dir and os.path.exists(self.temp_7z_dir):
            try:
                shutil.rmtree(self.temp_7z_dir)
                print(f"✓ Cleaned up temporary 7z files")
            except Exception as e:
                print(f"Warning: Could not clean up {self.temp_7z_dir}: {e}")
    
    def check_7z(self):
        """Check if 7z is available"""
        try:
            result = subprocess.run(['7z'], capture_output=True, text=True)
            return True
        except FileNotFoundError:
            return False
    
    def check_zip(self):
        """Check if zip command is available (Unix/Linux)"""
        try:
            result = subprocess.run(['zip', '-v'], capture_output=True, text=True)
            return True
        except FileNotFoundError:
            return False
    
    def package_with_7z(self, input_file, output_file):
        """Package using 7z with password protection"""
        try:
            cmd = ['7z', 'a', '-p' + self.password, '-mhe=on', output_file, input_file]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                return True, "Successfully packaged with 7z (strong AES-256 encryption)", False
            return False, f"7z error: {result.stderr}", False
        except Exception as e:
            return False, str(e), False
    
    def package_with_zip(self, input_file, output_file):
        """Package using zip command (Unix/Linux)"""
        try:
            cmd = ['zip', '-P', self.password, '-e', output_file, input_file]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                return True, "Successfully packaged with zip (standard encryption)", False
            return False, f"zip error: {result.stderr}", False
        except Exception as e:
            return False, str(e), False
    
    def package_with_pyminizip(self, input_file, output_file):
        """Package using pyminizip (requires: pip install pyminizip)"""
        try:
            import pyminizip
            compression_level = 5
            pyminizip.compress(input_file, None, output_file, self.password, compression_level)
            return True, "Successfully packaged with pyminizip (standard encryption)", False
        except ImportError:
            return False, "pyminizip not installed (pip install pyminizip)", False
        except Exception as e:
            return False, str(e), False
    
    def package_with_powershell(self, input_file, output_file):
        """Package using PowerShell's Compress-Archive, then password protect with 7z if available"""
        if self.system != "Windows":
            return False, "PowerShell only available on Windows", False
        
        try:
            # First create unprotected zip
            temp_zip = output_file.replace('.zip', '_temp.zip')
            ps_cmd = f'Compress-Archive -Path "{input_file}" -DestinationPath "{temp_zip}" -Force'
            result = subprocess.run(['powershell', '-Command', ps_cmd], capture_output=True, text=True)
            
            if result.returncode != 0:
                return False, f"PowerShell error: {result.stderr}", False
            
            # Try to add password with 7z if available
            if self.check_7z():
                protected_zip = output_file
                cmd = ['7z', 'a', '-p' + self.password, '-mhe=on', protected_zip, temp_zip]
                result = subprocess.run(cmd, capture_output=True, text=True)
                os.remove(temp_zip)  # Clean up temp file
                if result.returncode == 0:
                    return True, "Successfully packaged with PowerShell + 7z password protection", False
            
            # If 7z not available, rename temp to final (no password protection)
            os.rename(temp_zip, output_file)
            print("WARNING: No password protection applied (7z not available). Using certutil encoding...")
            return True, "Successfully packaged with PowerShell (WEAK - adding certutil encoding)", True
        except Exception as e:
            # Clean up temp file if it exists
            if 'temp_zip' in locals() and os.path.exists(temp_zip):
                os.remove(temp_zip)
            return False, str(e), False
    
    def package_with_python_zip(self, input_file, output_file):
        """Fallback: Package using Python's zipfile (legacy encryption - NOT recommended for sensitive data)"""
        try:
            with zipfile.ZipFile(output_file, 'w', zipfile.ZIP_DEFLATED) as zf:
                zf.setpassword(self.password.encode())
                zf.write(input_file, os.path.basename(input_file))
            print("WARNING: Python's zipfile uses weak ZipCrypto encryption. Adding certutil encoding...")
            return True, "Successfully packaged with Python zipfile (WEAK - adding certutil encoding)", True
        except Exception as e:
            return False, str(e), False
    
    def certutil_encode(self, zip_file):
        """Additional obfuscation layer using certutil (Windows only) - removes original zip"""
        if self.system != "Windows":
            return False, "certutil only available on Windows"
        
        try:
            encoded_file = zip_file.replace('.zip', '_suspicious.b64')
            cmd = ['certutil', '-encode', zip_file, encoded_file]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                # Remove the original zip file, keep only the encoded version
                os.remove(zip_file)
                print(f"✓ Applied certutil encoding (removed original zip)")
                print(f"  Final output: {encoded_file}")
                print(f"  (Decode with: certutil -decode {os.path.basename(encoded_file)} {os.path.basename(zip_file)})")
                return True, encoded_file
            return False, f"certutil error: {result.stderr}"
        except Exception as e:
            return False, str(e)
    
    def package_sample(self, input_path):
        """Main method to package a malware sample"""
        input_file = Path(input_path)
        
        if not input_file.exists():
            return False, f"File not found: {input_path}"
        
        # Create output filename
        base_name = input_file.stem
        output_file = str(input_file.parent / f"{base_name}_suspicious.zip")
        
        print(f"Packaging: {input_file}")
        print(f"Output: {output_file}")
        print(f"Password: {self.password}")
        print("-" * 50)
        
        # Check for 7z, download if not available
        has_7z = self.check_7z()
        if not has_7z:
            print("Attempting to download portable 7z...")
            has_7z = self.download_7z_portable()
        
        # Try methods in order of preference
        methods = [
            ("7z", lambda: has_7z, self.package_with_7z),
            ("zip command", self.check_zip, self.package_with_zip),
            ("pyminizip", lambda: True, self.package_with_pyminizip),
            ("PowerShell Compress-Archive", lambda: self.system == "Windows", self.package_with_powershell),
            ("Python zipfile", lambda: True, self.package_with_python_zip),
        ]
        
        for method_name, check_func, package_func in methods:
            if check_func():
                print(f"Trying {method_name}...")
                success, message, needs_encoding = package_func(str(input_file), output_file)
                if success:
                    print(f"✓ {message}")
                    
                    # Only apply certutil encoding for weak encryption methods
                    final_output = output_file
                    if needs_encoding and self.system == "Windows":
                        cert_success, cert_result = self.certutil_encode(output_file)
                        if cert_success:
                            final_output = cert_result
                    
                    print(f"\n✓ Sample packaged successfully!")
                    print(f"  Final output: {final_output}")
                    print(f"  Password: {self.password}")
                    
                    return True, final_output
                else:
                    print(f"✗ {method_name} failed: {message}")
            else:
                print(f"✗ {method_name} not available")
        
        return False, "All packaging methods failed"

def main():
    if len(sys.argv) < 2:
        print("Malware Sample Packager")
        print("Usage: python malware_zipper.py <file_path> [file_path2 ...]")
        print("\nPackages suspected malware samples with password 'infected'")
        print("Output format: <filename>_suspicious.zip")
        print("\nNote: Will automatically download portable 7z if not installed (Windows only)")
        sys.exit(1)
    
    packager = MalwarePackager()
    
    try:
        for file_path in sys.argv[1:]:
            print("\n" + "=" * 50)
            success, result = packager.package_sample(file_path)
            if not success:
                print(f"\n✗ Failed to package {file_path}: {result}")
            print("=" * 50)
    finally:
        # Always clean up downloaded 7z
        packager.cleanup_7z()

if __name__ == "__main__":
    main()